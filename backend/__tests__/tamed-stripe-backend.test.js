const tickLog = require("tick-log");
const tsb = require("../tamed-stripe-backend.js");
const sqls = require("../sqls.json");
const { runSQL, } = require('tamed-pg');

let poolName;
let debugMode = true; // true 

beforeAll(async () => {
	await tsb.init({
		debugMode: debugMode,
		// coming from database-setup
		pgKeys: {
			user: 'tamedstripeapp',
			password: 'tamedstripeapp.',
			database: 'tamedstripedb',
			host: 'localhost',
			port: 5432,
		},
	});
	poolName = tsb.exportedForTesting.poolInfoForTests.poolName;

});

test('generateCustomer', async () => {
	const now = new Date();
	const body = {
		description: `Jest Customer ${now}`,
		email: `test-${now.getTime()}@yopmail.com`,
		metadata: { "test": "test" },
		name: `Jest Customer ${now}`,
		phone: `1234567890`,
		address: { "line1": "1234 Main St", "city": "San Francisco", "state": "CA", "postal_code": "94111" },
		publicDomain: "https://development.eseme.one:61983",
		successRoute: "/generate-customer-success-route",
		cancelRoute: "/generate-customer-cancel-route",
	};
	const result1 = await tsb.generateCustomer(body);
	const customerData = result1.payload.customer;
	const checkoutSessionData = result1.payload.checkoutSession;
	expect(customerData.id).toBeTruthy();
	expect(checkoutSessionData).toBeTruthy();
	expect(checkoutSessionData.id).toBeTruthy();
	expect(checkoutSessionData.customer).toBeTruthy();
	expect(checkoutSessionData.customer).toBe(customerData.id);
	expect(checkoutSessionData.success_url).toBeTruthy();
	expect(checkoutSessionData.cancel_url).toBeTruthy();
	expect(checkoutSessionData.success_url).toBe(`${body.publicDomain}${body.successRoute}?session_id={CHECKOUT_SESSION_ID}`);
	expect(checkoutSessionData.cancel_url).toBe(`${body.publicDomain}${body.cancelRoute}?session_id={CHECKOUT_SESSION_ID}`);
	if (debugMode) tickLog.success(`generateCustomer result: ${JSON.stringify(customerData, null, 2)}`, true);
	if (debugMode) tickLog.success(`checkoutSessionData result: ${JSON.stringify(checkoutSessionData, null, 2)}`, true);
	let customerAtDB = await runSQL(poolName, sqls.selectCustomer, [customerData.id], debugMode);
	expect(customerAtDB.rows.length).toBe(1);
	expect(customerAtDB.rows[0].stripe_customer_id).toEqual(customerData.id);
	expect(customerAtDB.rows[0].customer_object).toEqual(customerData);
});


test('generateSubscription', async () => {

	const now = new Date();

	// This is a previously generated customer id and its credit card information 
	// 	is updated using the link from checkout session coming within the generateCustomer method.
	const customerId = 'cus_NULe1UNetgP3iq';

	const productName = `Product ${now}`;
	const productDescription = `Generated by JEST tests. Product ${now}`;
	const productCurrency = 'usd';
	const productAmount = "100001";
	const productProps = {
		name: productName,
		description: productDescription,
		currency: productCurrency,
		unitAmountDecimal: productAmount,
		interval: 'month',
	};
	const response2 = await tsb.generateProduct(productProps);
	const productData = response2.payload.product;
	const priceData = response2.payload.price;
	tickLog.info(`Product generated with following significant information:
		id:                  ${productData.id}
		name:                ${productData.name}
		description:         ${productData.description}
		type:                ${productData.type}
		default_price:       ${productData.default_price}
		livemode:            ${productData.livemode}
	`, true);
	tickLog.info(`price generated with following significant information:
		id:                  ${priceData.id},
		currency:            ${priceData.currency},
		livemode:            ${priceData.livemode},
		product:             ${priceData.product},
		interval:            ${priceData.recurring.interval},
		type:                ${priceData.type},
		unit_amount_decimal: ${priceData.unit_amount_decimal},
	  `, true);

	const response3 = await tsb.generateSubscription({
		customerId: customerId,
		recurringPriceId: priceData.id
	});
	tickLog.info(`response3: ${JSON.stringify(response3, null, 2)}`); // deleteme
	
});

test('generateAccount (connected account for payouts)', async () => {
	let publicDomain = "http://localhost:3000";
	let refreshUrlRoute = "/account-authorize";
	let returnUrlRoute = "/account-generated";

	let now = Date.now();
	let email = `${now}@yopmail.com`;
	const props = {
		email: email,
		publicDomain: publicDomain,
		refreshUrlRoute: refreshUrlRoute,
		returnUrlRoute: returnUrlRoute,
	};
	let response1 = await tsb.generateAccount(props);
	let accountData = response1.payload;
	tickLog.info(`Account generated with following significant information:\n   id:                  ${accountData.id}\n   type:                ${accountData.type}\n   capabilities:        ${JSON.stringify(accountData.capabilities)}\n   email:               ${accountData.email}\n   Payment Schedule:    ${JSON.stringify(accountData.settings.payouts.schedule)}\n   accountLinkURL:      ${accountData.accountLinkURL}`, true);
	expect(accountData.id).not.toBeNull();
	expect(accountData.type).toEqual('express');
	// jest compare object
	expect(accountData.capabilities).toEqual({ "transfers": "inactive" });
	expect(accountData.email).toEqual(email);
	expect(accountData.settings.payouts.schedule.interval).toEqual('daily');
	let accountAtDB = await runSQL(poolName, sqls.selectAccount, [accountData.id], debugMode);
	expect(accountAtDB.rows.length).toBe(1);
	expect(accountAtDB.rows[0].stripe_account_id).toEqual(accountData.id);
	expect(accountAtDB.rows[0].account_object).toEqual(accountData);
});

test('generateAccount (connected account for payouts) in TR', async () => {
	let publicDomain = "http://localhost:3000";
	let refreshUrlRoute = "/account-authorize";
	let returnUrlRoute = "/account-generated";

	let now = Date.now();
	let email = `${now}@yopmail.com`;
	const props = {
		email: email,
		publicDomain: publicDomain,
		refreshUrlRoute: refreshUrlRoute,
		returnUrlRoute: returnUrlRoute,
		country: "TR",
	};
	let response1 = await tsb.generateAccount(props);
	let accountData = response1.payload;
	tickLog.info(`Account generated with following significant information:\n   id:                  ${accountData.id}\n   type:                ${accountData.type}\n   capabilities:        ${JSON.stringify(accountData.capabilities)}\n   email:               ${accountData.email}\n   Payment Schedule:    ${JSON.stringify(accountData.settings.payouts.schedule)}\n   accountLinkURL:      ${accountData.accountLinkURL}`, true);
	expect(accountData.id).not.toBeNull();
	expect(accountData.type).toEqual('express');
	// jest compare object
	expect(accountData.capabilities).toEqual({ "transfers": "inactive" });
	expect(accountData.email).toEqual(email);
	expect(accountData.settings.payouts.schedule.interval).toEqual('daily');
	let accountAtDB = await runSQL(poolName, sqls.selectAccount, [accountData.id], debugMode);
	expect(accountAtDB.rows.length).toBe(1);
	expect(accountAtDB.rows[0].stripe_account_id).toEqual(accountData.id);
	expect(accountAtDB.rows[0].account_object).toEqual(accountData);
});

test('generateAccount (connected account for payouts) in FR', async () => {
	let publicDomain = "http://localhost:3000";
	let refreshUrlRoute = "/account-authorize";
	let returnUrlRoute = "/account-generated";

	let now = Date.now();
	let email = `${now}@yopmail.com`;
	const props = {
		email: email,
		publicDomain: publicDomain,
		refreshUrlRoute: refreshUrlRoute,
		returnUrlRoute: returnUrlRoute,
		country: "FR",
	};
	let response1 = await tsb.generateAccount(props);
	let accountData = response1.payload;
	tickLog.info(`Account generated with following significant information:\n   id:                  ${accountData.id}\n   type:                ${accountData.type}\n   capabilities:        ${JSON.stringify(accountData.capabilities)}\n   email:               ${accountData.email}\n   Payment Schedule:    ${JSON.stringify(accountData.settings.payouts.schedule)}\n   accountLinkURL:      ${accountData.accountLinkURL}`, true);
	expect(accountData.id).not.toBeNull();
	expect(accountData.type).toEqual('express');
	// jest compare object
	expect(accountData.capabilities).toEqual({ "transfers": "inactive" });
	expect(accountData.email).toEqual(email);
	expect(accountData.settings.payouts.schedule.interval).toEqual('daily');
	let accountAtDB = await runSQL(poolName, sqls.selectAccount, [accountData.id], debugMode);
	expect(accountAtDB.rows.length).toBe(1);
	expect(accountAtDB.rows[0].stripe_account_id).toEqual(accountData.id);
	expect(accountAtDB.rows[0].account_object).toEqual(accountData);
});

test('oneTimePayment without payOut', async () => {
	const now = new Date();

	// payoutData: {payoutAmount, payoutAccountId, useOnBehalfOf: true|false}
	// items: [{name, unitAmountDecimal}]
	// const { customerId, currency, items, payoutData, successUrl, cancelUrl } = body;
	// This is a previously generated customer id and its credit card information 
	// 	is updated using the link from checkout session coming within the generateCustomer method.
	const customerId = 'cus_NULe1UNetgP3iq';
	const currency = 'try';
	const items = [
		{ name: "iPhone", unitAmountDecimal: "100000" },
		{ name: "iPad", unitAmountDecimal: "200000" },
		{ name: "iMac", unitAmountDecimal: "300000" },
	];
	const payoutData = undefined;
	const publicDomain = "https://development.eseme.one:61983";
	const successRoute = "/one-time-payment-success-route";
	const cancelRoute = "/one-time-payment-cancel-route";
	const response4 = await tsb.oneTimePayment({ customerId, currency, items, payoutData, publicDomain, successRoute, cancelRoute });
	tickLog.info(`response4: ${JSON.stringify(response4, null, 2)}`); // deleteme
});

test('oneTimePayment with payOut to FR', async () => {
	const now = new Date();

	// payoutData: {payoutAmount, payoutAccountId, useOnBehalfOf: true|false}
	// items: [{name, unitAmountDecimal}]
	// const { customerId, currency, items, payoutData, successUrl, cancelUrl } = body;
	// This is a previously generated customer id and its credit card information 
	// 	is updated using the link from checkout session coming within the generateCustomer method.
	const customerId = 'cus_NULe1UNetgP3iq'; 
	// This is a previously generated account id
	const accountId = "acct_1MjkRw2HaPwigiek"; // 
	const currency = 'try';
	const items = [
		{ name: "iPhone", unitAmountDecimal: "100000" },
		{ name: "iPad", unitAmountDecimal: "200000" },
		{ name: "iMac", unitAmountDecimal: "300000" },
	];
	const payoutData = {
		payoutAmount: 450000, 
		payoutAccountId: accountId, 
		useOnBehalfOf: true
	};
	const publicDomain = "https://development.eseme.one:61983";
	const successRoute = "/one-time-payment-success-route";
	const cancelRoute = "/one-time-payment-cancel-route";
	const response4 = await tsb.oneTimePayment({ customerId, currency, items, payoutData, publicDomain, successRoute, cancelRoute });
	tickLog.info(`response4: ${JSON.stringify(response4, null, 2)}`); // deleteme
});

test('oneTimePayment with payOut to TR', async () => {
	const now = new Date();

	// payoutData: {payoutAmount, payoutAccountId, useOnBehalfOf: true|false}
	// items: [{name, unitAmountDecimal}]
	// const { customerId, currency, items, payoutData, successUrl, cancelUrl } = body;
	// This is a previously generated customer id and its credit card information 
	// 	is updated using the link from checkout session coming within the generateCustomer method.
	const customerId = 'cus_NULe1UNetgP3iq'; 
	// This is a previously generated account id
	const accountId = "acct_1Mjivf2HrSbgvhw4"; // "message":"TR is not currently supported by Stripe."
	const currency = 'try';
	const items = [
		{ name: "iPhone", unitAmountDecimal: "100000" },
		{ name: "iPad", unitAmountDecimal: "200000" },
		{ name: "iMac", unitAmountDecimal: "300000" },
	];
	const payoutData = {
		payoutAmount: 4500, 
		payoutAccountId: accountId, 
		useOnBehalfOf: true
	};
	const publicDomain = "https://development.eseme.one:61983";
	const successRoute = "/one-time-payment-success-route";
	const cancelRoute = "/one-time-payment-cancel-route";
	const response4 = await tsb.oneTimePayment({ customerId, currency, items, payoutData, publicDomain, successRoute, cancelRoute });
	tickLog.info(`response4: ${JSON.stringify(response4, null, 2)}`); // deleteme
});
